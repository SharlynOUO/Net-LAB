# 作业一：套接字编程

套接字编程是编写通过网络通信的程序的标准方法。 虽然最初是为用 C 编程的 Unix 计算机开发的，但套接字抽象是通用的，不依赖于任何特定的操作系统或编程语言。 这允许程序员在许多情况下使用套接字来编写正确的网络程序。

这部分作业将为你提供基本套接字编程的经验。你将编写2对 TCP 客户端和服务器程序，用于通过 Internet 发送和接收文本消息。一对客户端/服务器必须用 C 编写。另一对可以用 Python 或 Go 编写，你需要从 Python 和 Go 中选择一种作为第二对客户端/服务器的实现语言。

两种语言的客户端和服务器程序应满足相应的规范，请务必在编程前后仔细阅读这些内容，以确保你的实现满足它们。

## Server 规范

- 每个服务器程序都应该监听一个套接字，等待客户端连接，从客户端接收消息，将消息打印到标准输出，然后无限期地等待下一个客户端连接。
- 每个服务器都应采用一个命令行参数：侦听客户端连接的端口号。
- 每个服务器应该在无限循环中接受和处理客户端通信，允许多个客户端向同一服务器发送消息。 服务器应该只在响应外部信号时退出（例如，按下 ctrl-c 的 SIGINT 时）。
- 每台服务器应维护一个短的（5-10）客户端队列并按顺序处理多个客户端连接尝试。在现实生活中的实际应用程序中，TCP 服务器会派生一个新进程来同时处理每个客户端连接，但这并不是本次作业中你需要做的。
- 每个服务器都应该适宜地处理可能由套接字编程库函数返回的错误值（请参阅下面每种语言的详细信息），处理客户端连接相关的错误不应导致服务器在处理错误后退出，所有其他的处理都是这样。

## Client 规范

- 每个客户端程序应该连接服务器，从标准输入读取消息，发送消息，然后退出。
- 每个客户端都应该按照它在标准输入中的显示方式读取和发送消息，直到到达 EOF（文件结尾）。
- 每个客户端都应该接受两个命令行参数：服务器的 IP 地址和服务器的端口号。
- 每个客户端必须能够通过循环迭代来读取和发送消息块来处理比较大的消息，而不是直接先将整个消息读入内存。
- 每个客户端应通过尝试重新发送其余数据直到全部发送完来处理部分发送（当套接字仅传输上次发送调用中给出的部分数据时）。
- 每个客户端都应该适宜地处理可能由套接字编程库函数返回的错误值。

## 编程指导和参考资料

你需要在之前用 Vagrant 创建的虚拟机上进行所有的代码编译、运行和测试。 你可以直接在虚拟机上编写代码（比如使用 Vim 文本编辑器）或直接在你的主机操作系统上使用任何你喜欢的编辑器进行编写（因为我们已经设置了虚拟机和主机之间的共享文件夹）。 从终端运行 vagrant ssh 后，你应当已经处在 /vagrant 课程目录下了。

我们在 client_server/ 目录中提供了代码框架。 在开始编程之前，你应该阅读并理解此代码。你应该只在标有 TODO 注释的所提供文件的位置进行编程。 每个客户端一个 TODO 部分，每个服务器一个。 你可以根据需要添加函数，但不要更改文件名，因为它们将用于自动化测试。

以下部分提供了每种语言的客户端和服务器程序的参考资料。

### C

可以参考经典的[Beej 网络编程指南](https://beej.us/guide/bgnet/html/)。其中的 [System Calls or Bust](https://beej.us/guide/bgnet/html/#system-calls-or-bust) 和 [Client-Server Background](https://beej.us/guide/bgnet/html/#client-server-background) 部分将是与本次作业最相关的。[Man Pages](https://beej.us/guide/bgnet/html/#man-pages)对于查找单个函数（例如 socket）也很有用。

文件 client-c.c 和 server-c.c 已经包含了代码框架。你需要在标记为 TODO 的位置添加套接字编程和 I/O 代码。一般来说你可能需要在每个文件的 TODO 部分中插入大约 70 行代码（有较好的注释和间隔）。你的实现可以更短或更长。

对于错误处理，可以为设置全局变量 errno 的套接字编程函数调用 perror（Beej 指南会告诉你执行哪个操作）。对于那些不这样做的同学，只需将消息打印到标准错误即可。

你应该通过在 client_server 目录中运行 make 来构建你的解决方案。你的代码必须使用提供的 Makefile 构建。服务器应该运行为 `./server-c [port] > [output file]`。客户端应该运行为 `./client-c [server IP] [server port] < [message file]`。有关详细信息，请参阅本文档的“测试”部分。

### Python

这里是 Python socket 编程的[文档链接](https://docs.python.org/2/library/socket.html)。[socket objects](https://docs.python.org/2/library/socket.html#socket-objects) 的顶部的前几段和 [example](https://docs.python.org/2/library/socket.html#example) 的全部内容与本次作业特别相关。

文件 client-python.py 和 server-python.py 已经包含了代码框架。 你需要在标记为 TODO 的位置添加套接字编程代码。一般来说你可能需要在每个文件的 TODO 部分中插入大约 15 行代码。你的实现可以更短或更长。

Python 套接字函数将自动引发异常并提供有用的错误消息。不需要额外的错误处理。

服务器应该运行为 `python server-python.py [port] > [output file]`。 客户端应该运行为 `python client-python.py [server IP] [server port] < [message file]`。 有关详细信息，请参阅本文档的“测试”部分。

### Go

这里是 Go socket 编程的[文档链接](https://golang.org/pkg/net/)，顶部的概述和关于 [type Conn](https://golang.org/pkg/net/#Conn) 的部分与本作业是最相关的。

文件 client-go.go 和 server-go.go 已经包含了代码框架。 你需要在标记为 TODO 的位置添加套接字编程代码。 一般来说你可能需要在每个文件的 TODO 部分中插入大约 40 行代码。你的实现可以更短或更长。

Go Listen 函数默认维护一个连接客户端队列。 不需要额外的编程。

你应该通过在 `client_server` 目录中运行 `make go `来构建你的解决方案。 你的代码必须使用提供的 Makefile 构建。 服务器应该运行为 `./server-go [port] > [output file]`。 客户端应该运行为 `./client-go [server IP] [server port] < [message file]`。 有关详细信息，请参阅本文档的“测试”部分。

## 测试

你应该通过尝试将消息从客户端发送到服务器来测试你的实现。服务器可以在后台运行（将 & 附加到命令中）或在单独的 SSH 窗口中运行。你应该使用 127.0.0.1 作为服务器 IP，并使用介于 10000 和 60000 之间的服务器端口号。你可以使用 fg 命令将其带到前台然后按 ctrl-c 将其杀死。

Bash 脚本 `test_client_server.sh` 将通过尝试在客户端和服务器的所有 4 种组合（C 客户端到 C 服务器、C 客户端到 Python/Go 服务器等）之间发送几个不同的消息来测试你的实现。 消息如下：

1. 短信“Go Tigers!\n”
2. 一条长的、随机生成的字母数字消息
3. 一条长的、随机生成的二进制消息
4. 多条短信从不同的客户端依次发送到一台服务器
5. 几条长的、随机的字母数字消息从不同的客户端并发发送到一台服务器

运行脚本：

```./test_client_server.sh [python|go] [server port]```

如果你收到权限错误，请运行 `chmod 744 test_client_server.sh ` 以授予脚本可执行权限。

对于每个客户端/服务器对，如果消息发送和接收正确，测试脚本将打印“SUCCESS”。 否则，如果 diff 输出是人类可读的，即仅用于测试 1 和 4，它将打印发送和接收消息的差异。

确保在运行` test_client_server.sh` 之前通过 ```make``` 编译你的客户端/服务器对。

## 调试提示

这里有一些调试技巧供参考。 

- 代码框架中定义了缓冲区大小和队列长度常量，你可使用它们，但如果它们未在特定文件中定义，则说明不需要它们。但如果不是这两种情况其中之一，则要么你硬编码了一个值，这是不好的方式，要么你可能做错了什么。
- 在 C、Python 和 Go 中，有多种方法可以从 stdin/stdout 读取和写入。任何方法都是可以接受的，只要它不会一次无限量读入内存并且不会修改消息。
- 如果你使用缓冲 I/O 写入stdout，请确保调用flush，否则可能无法写入长消息的结尾。
- 请记住在客户端程序结束时关闭套接字。
- 测试时，确保使用 127.0.0.1 作为客户端的服务器 IP 参数，并且客户端和服务器程序使用相同的服务器端口。
- 如果你收到“地址已在使用”错误，请确保你还没有运行服务器。否则，使用命令 logout 和 vagrant ssh 重新启动你的 ssh 会话。
- 如果你遇到其他连接错误，请尝试使用介于 10000 和 60000 之间的不同端口。

## FAQ

* 我应该在recv() 上设置MSG_WAITALL 标志吗？ 不用，这会导致 recv() 在接收到指定数量的数据之前不会返回。但是，服务器不能提前知道这个数量，所以你应该继续调用 recv() 直到没有任何东西可以接收。
* 当用户按下 ctrl-c 时，我是否需要处理诸如SIGINT这样的信号来清理服务器进程？ 不需要，在这个任务中没有必要，对信号的默认响应已经足够好了，当然这样做没有问题。
* 我应该使用流套接字还是数据报套接字？ 请使用流套接字，以确保传递消息的准确，不保证传送的是数据报包。
* 客户端是否应该等待接收来自服务器的回复？ 不需要，在这个作业中，在发送完所有数据后它应该立即退出。
* 服务器是否应该（在不同的进程中）同时处理客户端连接？ 不用，正如客户规范中所述，本作业不需要这样做。 所以不需要使用 fork() ！
* 我可以只选择 Python 和 Go 吗? 不可以，C 客户端/服务器是必须的。 在这之外，还应该在 Python 或 Go 中提交另一个客户端/服务器，但不能同时提交！ 如果你同时提交了 Python 和 Go，我们只会对你的 Python 文件进行评分。此外，你的第二对客户端/服务器对必须使用相同的语言，也就是，不能提交 Python 的客户端和 Go 的服务器，或者相反。
